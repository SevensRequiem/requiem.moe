const pages = [
    { name: 'home', url: './home' },
    { name: 'blog', url: './blog' },
    { name: 'projects', url: './projects' },
    { name: 'versions', url: './version' },
    { name: 'tools', url: './tools' },
    { name: 'gallery', url: './gallery' },
    { name: 'store', url: './store' },
    { name: 'about', url: './about' },
    { name: 'donate', url: './donate' }
  ];
  
  function loadPage(pageName) {
    const page = pages.find(p => p.name === pageName);
    if (!page) {
      console.error(`Page ${pageName} not found`);
      return;
    }
    const content = document.getElementById("content");
    const loadingBar = document.createElement("div");
    loadingBar.className = "loading-bar";
    content.appendChild(loadingBar);
    fetch(page.url)
      .then(response => response.text())
      .then(data => {
        const parser = new DOMParser();
        const xmlDoc = parser.parseFromString(data, "text/html");
        const newContent = xmlDoc.querySelector("#content");
        if (newContent) {
          content.parentNode.replaceChild(newContent, content);
          if (pageName === 'home') {
            axios.get('/get-messages')
            .then(function (response) {
              var messages = response.data.messages;
              var chatbox = document.getElementById('chatbox');
              messages.forEach(function (message) {
                var chatmessage = document.createElement('div');
                chatmessage.className = 'chatmessage';
                
                var chatid = document.createElement('span');
                chatid.className = 'chatid';
                chatid.innerHTML = "[" + message.id + "]";
                var chattimestamp = document.createElement('span');
                chattimestamp.className = 'chattimestamp';
                var date = new Date(message.timestamp * 1000);
                chattimestamp.innerHTML = "[" + date.toLocaleString() + "]";
                
                var chatusername = document.createElement('span');
                chatusername.className = 'chatusername';
                if (message.trueuser && message.trueuser !== 'none') {
                  chatusername.innerHTML = "*[" + message.username + "]";
                } else if (message.trueuser === 'none' && message.username !== 'Anonymous') {
                  chatusername.innerHTML = "~[" + message.username + "]";
                } else {
                  chatusername.innerHTML = "[" + message.username + "]";
                }
                chatusername.setAttribute('alt', message.trueuser);
                
                var chatmessagecontent = document.createElement('p');
                chatmessagecontent.className = 'chatmessagecontent';
                chatmessagecontent.innerHTML = message.message;
                
                chatmessage.appendChild(chatid);
                chatmessage.appendChild(chatusername);
                chatmessage.appendChild(chatmessagecontent);
                chatmessage.appendChild(chattimestamp);
                
                chatbox.appendChild(chatmessage);
                
                var hr = document.createElement('hr');
                chatbox.appendChild(hr);
              });
            })
            .catch(error => console.error(error));
          }
        }
      })
      .catch(error => console.error(error))
      .finally(() => { // requiemdotmoe was here
        content.removeChild(loadingBar);
      });
  }
  function loadForm() {
    var form = document.getElementById("contactform");
    if (form.style.display === "none" || form.style.display === "") {
      form.style.display = "block";
      form.addEventListener("submit", function(event) {
        event.preventDefault();
        submitForm();
      });
    } else {
      form.style.display = "none";
    }
  
    var chatform = document.getElementById("chatform");
    if (chatform.style.display === "none" || chatform.style.display === "") {
      chatform.style.display = "block";
      chatform.addEventListener("submit", function(event) {
        event.preventDefault();
        submitChat();
      });
    } else {
      chatform.style.display = "none";
    }
  }
  
  function loadDonate() {
    var donateform = document.getElementById("donate-box");
    if (donateform.style.display === "none" || donateform.style.display === "") {
      donateform.style.display = "block";
      donateform.addEventListener("submit", function(event) {
        event.preventDefault();
        submitDonate();
      });
    } else {
      donateform.style.display = "none";
    }
  }
  // made by https://requiem.moe/
var requiemMoeAudio = document.getElementById("requiemMoeAudio");
requiemMoeAudio.volume = 0.2;
var requiemMoePlaylist = document.getElementById("requiemMoePlaylist").getElementsByTagName("a");
var requiemMoeControls = document.getElementById("requiemMoeControls").getElementsByTagName("a");
var requiemMoeVolumeControl = document.getElementById("requiemMoeVolumeControl");
var requiemMoeVolumeLevel = document.getElementById("requiemMoeVolumeLevel");
var requiemMoeCurrentTrack = 0;
function requiemMoePlayAudio() {
  requiemMoeAudio.play();
}
function requiemMoePlayPause() {
  if (requiemMoeAudio.paused) {
    requiemMoeAudio.play();
  } else {
    requiemMoeAudio.pause();
  }
  requiemMoeUpdatePlayPauseButton();
}
function requiemMoeUpdatePlayPauseButton() {
  if (requiemMoeAudio.paused) {
    requiemMoeControls[0].innerHTML = '[<span>&gt;</span>/<span class="glow">#</span>]';
    requiemMoeControls[0].classList.remove("pulse");
    requiemMoeControls[0].classList.add("glow");
  } else {
    requiemMoeControls[0].innerHTML = '[<span class="pulse">&gt;</span>/<span>#</span>]';
    requiemMoeControls[0].classList.remove("glow");
    requiemMoeControls[0].classList.add("pulse");
  }
}
function requiemMoeSkip(direction) {
  requiemMoeCurrentTrack += direction;
  if (requiemMoeCurrentTrack < 0) {
    requiemMoeCurrentTrack = requiemMoePlaylist.length - 1;
  } else if (requiemMoeCurrentTrack > requiemMoePlaylist.length - 1) {
    requiemMoeCurrentTrack = 0;
  }
  requiemMoeAudio.src = requiemMoePlaylist[requiemMoeCurrentTrack].getAttribute("data-src");
  requiemMoePlayAudio();
}
function requiemMoeChangeVolume(event) {
  event.preventDefault();
  var direction = Math.sign(event.deltaY);
  requiemMoeAudio.volume -= direction * 0.1;
  if (requiemMoeAudio.volume < 0) {
    requiemMoeAudio.volume = 0;
  } else if (requiemMoeAudio.volume > 1) {
    requiemMoeAudio.volume = 1;
  }
  requiemMoeUpdateVolumeLevel();
}
function requiemMoeUpdateVolumeLevel() {
  var level = Math.round(requiemMoeAudio.volume * 10);
  var levelString = "[";
  for (var i = 0; i < 10; i++) {
    if (i < level) {
      levelString += "=";
    } else {
      levelString += "-";
    }
  }
  levelString += "]";
  requiemMoeVolumeLevel.innerHTML = levelString;
}
function requiemMoeUpdateTrackInfo() {
  var requiemMoeCurrentTrackElement = document.getElementById("requiemMoeCurrentTrack");
  var requiemMoeCurrentDurationElement = document.getElementById("requiemMoeCurrentDuration");
  var requiemMoeRemainingDurationElement = document.getElementById("requiemMoeRemainingDuration");
  requiemMoeCurrentTrackElement.innerHTML = requiemMoePlaylist[requiemMoeCurrentTrack].innerHTML;
  requiemMoeCurrentDurationElement.innerHTML = requiemMoeFormatTime(requiemMoeAudio.currentTime);
  requiemMoeRemainingDurationElement.innerHTML = requiemMoeFormatTime(requiemMoeAudio.duration - requiemMoeAudio.currentTime);
}
function requiemMoeFormatTime(seconds) {
  var minutes = Math.floor(seconds / 60);
  var remainingSeconds = Math.floor(seconds % 60);
  if (remainingSeconds < 10) {
    remainingSeconds = "0" + remainingSeconds;
  }
  return minutes + ":" + remainingSeconds;
}
requiemMoeAudio.addEventListener("timeupdate", function () {
  requiemMoeUpdateTrackInfo();
});
function requiemMoeTogglePlaylist() {
  var requiemMoePlaylist = document.getElementById("requiemMoePlaylist");
  requiemMoePlaylist.classList.toggle("show");
}
requiemMoeAudio.src = requiemMoePlaylist[requiemMoeCurrentTrack].getAttribute("data-src");
requiemMoeUpdatePlayPauseButton();
requiemMoeUpdateVolumeLevel();
requiemMoeAudio.addEventListener("ended", function () {
  requiemMoeSkip(1);
});
for (var i = 0; i < requiemMoePlaylist.length; i++) {
  requiemMoePlaylist[i].addEventListener("click", function (event) {
    event.preventDefault();
    requiemMoeAudio.src = this.getAttribute("data-src");
    requiemMoeCurrentTrack = Array.prototype.indexOf.call(requiemMoePlaylist, this);
    requiemMoePlayAudio();
    requiemMoeUpdatePlayPauseButton();
  });
}
requiemMoeVolumeControl.addEventListener("input", function () {
  requiemMoeAudio.volume = this.value / 100;
  requiemMoeUpdateVolumeLevel();
});
// made by https://requiem.moe/
document.addEventListener('click', function(e) {
    if (e.target.classList.contains('submit-comment')) {
        e.preventDefault();
        var form = e.target.closest('form');
        var postuuid = form.querySelector('.postuuid').value;
        var author = form.querySelector('.username').value;
        var comment = form.querySelector('.comment').value;

        axios.post('/blog-comment', {
            postuuid: postuuid,
            author: author,
            comment: comment,
            _token: document.querySelector('meta[name="csrf-token"]').getAttribute('content')
        })
            .then(function(response) {
                console.log(response);
                if (response.status === 200) {
                    location.reload();
                }
            })
            .catch(function(error) {
                console.log(error);
            });
    }
});
var stripe = Stripe(
    'pk_live_51OoEq7FFweABEjfJhD7dqZqhOuvXXSWbh7gdqPziIVSYAjft7AxlRQ4tpvzPLEy9x7wFsuBFIcOMOdQXGWPJ0uMT00ICiiGeNs'
    );

var form = document.getElementById('payment-form');
form.addEventListener('submit', function(ev) {
    ev.preventDefault();

    fetch('/create-checkout-session', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRF-TOKEN': '{{ csrf_token() }}'
            },
            body: JSON.stringify({
                amount: form.amount.value,
                recurring: form.recurring.checked
            })
        })
        .then(function(response) {
            return response.json();
        })
        .then(function(session) {
            return stripe.redirectToCheckout({
                sessionId: session.id
            });
        })
        .then(function(result) {
            if (result.error) {
                alert(result.error.message);
            }
        })
        .catch(function(error) {
            console.error('Error:', error);
        });
});
// made by https://requiem.moe/
const sampleRate = 44100;
const frequencyLeft = 106.13;
const frequencyRight = 113.96;
const volumeLeft = 0.0013;
const volumeRight = 0.0013;
const audioContext = new AudioContext({ sampleRate });
const bufferSize = sampleRate;
const audioBuffer = audioContext.createBuffer(2, bufferSize, sampleRate);
const leftChannel = audioBuffer.getChannelData(0);
const rightChannel = audioBuffer.getChannelData(1);
for (let i = 0; i < bufferSize; i++) {
  const t = i / sampleRate;
  leftChannel[i] = volumeLeft * Math.sin(2 * Math.PI * frequencyLeft * t);
  rightChannel[i] = volumeRight * Math.sin(2 * Math.PI * frequencyRight * t);
}
const audioSource = audioContext.createBufferSource();
audioSource.buffer = audioBuffer;
audioSource.loop = true;
audioSource.connect(audioContext.destination);
audioSource.start();
const audioElement = document.getElementById("resonance");
audioElement.src = audioContext.createMediaElementSource(audioSource).connect(audioContext.destination);
// made by https://requiem.moe/
function animateGhost1(ghost, ghcontainer) {
    let x = Math.random() * (ghcontainer.clientWidth - 55);
    let y = Math.random() * (ghcontainer.clientHeight - 55);
    let dx = (Math.random() - 0.5) * 5;
    let dy = (Math.random() - 0.5) * 5;
    let lastChange = Date.now();
    let direction = dx > 0 ? 'right' : 'left'; // Initialize direction based on initial dx value
    let zIndex = 0;
    let size = 30;
    let opacity = Math.random() * 0.4 + 0.6; // Random opacity between 0.6 and 1

    // Set initial position, size, and opacity randomly
    ghost.style.left = `${x}px`;
    ghost.style.top = `${y}px`;
    ghost.style.width = `${size}px`;
    ghost.style.height = `${size}px`;
    ghost.style.opacity = opacity;

    // Add a class to set z-index and initial flip
    ghost.classList.add('ghost');

    // Handle flipping when moving left/right
    ghost.addEventListener('animationiteration', () => {
        ghost.classList.toggle('flip');
    });

    // Adjust ghcontainer size
    ghcontainer.style.width = `${ghcontainer.clientWidth}px`;
    ghcontainer.style.height = `${ghcontainer.clientHeight}px`;

    setInterval(() => {
        zIndex += Math.floor(Math.random() * 5) - 2; // Change z-index by -2 to 2
        zIndex = Math.min(Math.max(zIndex, -99), 99); // Clamp z-index between -99 and 99
        ghost.style.zIndex = zIndex;

        size += Math.floor(Math.random() * 5) - 2; // Change size by -2 to 2
        size = Math.min(Math.max(size, 30), 55); // Clamp size between 30 and 55
        ghost.style.width = `${size}px`;
        ghost.style.height = `${size}px`;
    }, 1000);

    function animate() {
        requestAnimationFrame(animate);

        const now = Date.now();
        const elapsed = now - lastChange;

        if (elapsed > (Math.random() * 10000 + 3000)) {
            dx = (Math.random() - 0.5) * 5;
            dy = (Math.random() - 0.5) * 5;
            lastChange = now;
            if (dx > 0 && direction === 'left') {
                direction = 'right';
                ghost.style.transform = 'scaleX(-1)';
            } else if (dx < 0 && direction === 'right') {
                direction = 'left';
                ghost.style.transform = 'scaleX(1)';
            }
        }

        x += dx;
        y += dy;

        if (x < 0 || x > ghcontainer.clientWidth - size) {
            dx = -dx;
            x += dx * 2;
            if (dx > 0 && direction === 'left') {
                direction = 'right';
                ghost.style.transform = 'scaleX(-1)';
            } else if (dx < 0 && direction === 'right') {
                direction = 'left';
                ghost.style.transform = 'scaleX(1)';
            }
        }

        if (y < 0 || y > ghcontainer.clientHeight - size) {
            dy = -dy;
            y += dy * 2;
        }

        ghost.style.left = `${x}px`;
        ghost.style.top = `${y}px`;
        ghost.style.opacity = `${opacity + (Math.random() - 0.5) * 0.05}`;
    }

    animate();
}

const ghost1 = document.getElementById('ghost1');
const ghcontainer = document.getElementById('sprite-container');

animateGhost1(ghost1, ghcontainer);
const canvas = document.getElementById('stars')
canvas.width = 1280 
canvas.height = 720 // moe
canvas.style.width = '100%'
canvas.style.height = '100%'
const ctx = canvas.getContext('2d')
let stars = []
const minNumStars = 250,
  maxNumStars = 1500,
  minMaxStarSize = 0.3,
  maxMaxStarSize = 1.3,
  maxStarSize = // r
    Math.random() * (maxMaxStarSize - minMaxStarSize) + minMaxStarSize,
  minMaxStarSpeed = 0.1,
  maxMaxStarSpeed = 1,
  maxStarSpeed =
    Math.random() * (maxMaxStarSpeed - minMaxStarSpeed) + minMaxStarSpeed,
  minMaxStarOpacity = 0.8,
  maxMaxStarOpacity = 1,
  maxStarOpacity =
    Math.random() * (maxMaxStarOpacity - minMaxStarOpacity) + minMaxStarOpacity

let fps = 0 // e
let frameCount = 0
let lastTime = performance.now()
let fpsHistory = []
let numStars = 80

function updateFps() {
  const now = performance.now()
  const elapsed = now - lastTime
  if (elapsed > 1000) {
    fps = frameCount
    frameCount = 0 // q
    lastTime = now
    fpsHistory.push(fps)
    if (fpsHistory.length > 15) {
      fpsHistory.shift()
    }
    const avgFps = fpsHistory.reduce((a, b) => a + b, 0) / fpsHistory.length
    document.getElementById('fps').innerHTML = Math.round(avgFps)
    if (document.getElementById('bench').innerHTML === '(ー◡ーゞ') {
      numStars = 1000 
    } else {
      numStars = Math.floor((avgFps / 60) * 1500) // calculate numStars based on average FPS, idk math so this is probably wrong??
    }
    if (numStars > stars.length) { // u
      for (let i = stars.length; i < numStars; i++) {
        stars.push(new Star())
      }
    } else if (numStars < stars.length) {
      stars.splice(numStars, stars.length - numStars)
    }
  }
  frameCount++
}

class Star {
  constructor() {
    this.x = Math.random() * canvas.width
    this.y = Math.random() * canvas.height // i
    this.size = Math.random() * maxMaxStarSize + minMaxStarSize
    this.speed = Math.random() * maxMaxStarSpeed + minMaxStarSpeed
    this.opacity = Math.random() * maxMaxStarOpacity + minMaxStarOpacity
    this.color =
      'rgb(' +
      Math.floor(Math.random() * 256) +
      ', ' + // e
      Math.floor(Math.random() * 256) +
      ', ' +
      Math.floor(Math.random() * 256) +
      ')'
  }
  ['update']() {
    this.x -= this.speed
    this.x < -this.size && // m
      ((this.x = canvas.width + this.size),
      (this.y = Math.random() * canvas.height),
      (this.opacity = Math.random() * maxMaxStarOpacity + minMaxStarOpacity))
    Math.random() < 0.05 && (this.opacity = Math.random() * maxMaxStarOpacity + minMaxStarOpacity)
  }
  ['draw']() {
    const _0x413a33 = ctx.createRadialGradient(
      this.x,
      this.y,
      0,
      this.x,
      this.y,
      this.size
    )
    _0x413a33.addColorStop(0, this.color)
    _0x413a33.addColorStop(0.5, 'rgba(255, 255, 255, ' + this.opacity + ')')
    _0x413a33.addColorStop(1, 'rgba(255, 255, 255, 0)')
    ctx.beginPath()
    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2)
    ctx.fillStyle = _0x413a33
    ctx.fill()
  }
}

function animate() {
  ctx.clearRect(0, 0, canvas.width, canvas.height)
  for (let _0x3c3913 = 0; _0x3c3913 < stars.length; _0x3c3913++) {
    stars[_0x3c3913].update()
    stars[_0x3c3913].draw()
  }
  updateFps()
  requestAnimationFrame(animate)
}

let bench = document.getElementById('bench')
let benchTime = 0
let benchInterval = setInterval(() => {
  benchTime++
  if (benchTime >= 15) {
    clearInterval(benchInterval)
    bench.innerHTML = '(ー◡ーゞ'
  }
}, 1000)

requestAnimationFrame(animate)